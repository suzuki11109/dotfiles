#+STARTUP: overview
* Scala
#+begin_src emacs-lisp
(use-package scala-mode
  :custom
  (scala-indent:align-parameters t)
  (scala-indent:use-javadoc-style t)
  :interpreter ("scala" . scala-mode)
  :mode "\\.scala\\'"
  :mode "\\.sbt\\'")

(use-package sbt-mode
  :general
  (+local-leader-def
    :keymaps '(scala-mode-map)
    "b" '(nil :wk "sbt")
    "bb" #'sbt-command
    "bc" #'sbt-compile
    "br" #'sbt-start
    "b." #'sbt-run-previous-command
    "t" '(nil :wk "test")
    "ta" '(sbt-do-test :wk "Test quick")
    "tf" '(+sbt-test-file :wk "Test current file")
    ;; "tt" '(nil :wk "Test quick")
  )
  :commands sbt-start sbt-command
  :init
  (defun +sbt-get-testonly-file (&optional file)
    "Return FILE formatted in a sbt testOnly command."
    (--> (or file (file-name-base))
         (format "testOnly *%s" it)))

  (defun +sbt-test-file (&optional file)
    (interactive)
    (sbt-command (+sbt-get-testonly-file file)))

  ;; (defun +sbt-get-testcase-name ()
  ;;   "Get Scala test case nearby point."
  ;;   (interactive)
  ;;   (save-excursion
  ;;     (let* ((line (thing-at-point 'line t))
  ;;            (on-testcase-p (and (s-contains? "\"" line)
  ;;                                (s-contains? "{\n" line)))
  ;;            (get-testcase-name (lambda (l)
  ;;                                 (--> l
  ;;                                      (s-split "\"" it)
  ;;                                      reverse
  ;;                                      cl-second))))
  ;;       (if on-testcase-p
  ;;           (funcall get-testcase-name line)
  ;;         (progn
  ;;           (search-backward "{\n")
  ;;           (funcall get-testcase-name (thing-at-point 'line t)))))))

  ;; (defun +sbt-run-testcase-at-point ()
  ;;   "Run Scala test case at point."
  ;;   (interactive)
  ;;   (sbt-command (format "%s -- -z \"%s\"" (+sbt-get-testonly-file) (+sbt-get-testcase-name))))
  :config
  ;; WORKAROUND: https://github.com/ensime/emacs-sbt-mode/issues/31
  ;; allows using SPACE when in the minibuffer
  (substitute-key-definition
   'minibuffer-complete-word
   'self-insert-command
   minibuffer-local-completion-map)
  ;; sbt-supershell kills sbt-mode:  https://github.com/hvesalai/emacs-sbt-mode/issues/152
  (setq sbt:program-options '("-Dsbt.supershell=false")))

;; (use-package lsp-metals
;;   :general
;;   (+local-leader-def
;;     :keymaps '(scala-mode-map)
;;     "fn" #'lsp-metals-new-scala-file)
;;   :custom
;;   (lsp-metals-server-args '("-J-Dmetals.allow-multiline-string-formatting=off"))
;;   :hook
;;   (scala-mode . lsp-deferred))
 #+end_src

* Kotlin
#+begin_src emacs-lisp
(use-package kotlin-ts-mode
  :mode "\\.kt\\'"
  :hook
  (kotlin-ts-mode . lsp-deferred)
  :config
  (require 'dap-kotlin)
  (dap-register-debug-template "Kotlin tests with launcher"
                               (list :type "kotlin"
                                     :request "launch"
                                     :mainClass "org.junit.platform.console.ConsoleLauncher --scan-classpath"
                                     :enableJsonLogging nil
                                     :noDebug nil))

  )
#+end_src
* Lsp
#+begin_src emacs-lisp
(use-package lsp-mode
  :commands (lsp lsp-deferred lsp-install-server)
  :config
  (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]vendor")
  (lsp-register-custom-settings
   '(("gopls.completeUnimported" t t)
     ("gopls.staticcheck" t t)))
  :custom
  (lsp-keymap-prefix nil)
  (lsp-completion-provider :none)
  (lsp-headerline-breadcrumb-enable nil)
  (lsp-keep-workspace-alive nil)
  (lsp-enable-symbol-highlighting nil)
  (lsp-enable-text-document-color nil)
  (lsp-signature-auto-activate nil)
  ;; (lsp-semantic-tokens-enable t)
  (lsp-signature-render-documentation nil)
  (lsp-modeline-code-action-fallback-icon "󰌶")
  (lsp-auto-execute-action nil)
  (lsp-disabled-clients '(rubocop-ls))
  (lsp-kotlin-compiler-jvm-target "2.1")
  (lsp-kotlin-debug-adapter-path "~/.config/emacs/.cache/adapter/kotlin/bin/kotlin-debug-adapter")
  (lsp-clients-typescript-prefer-use-project-ts-server t)
  (lsp-javascript-implicit-project-config-check-js t)
  (lsp-javascript-suggest-complete-js-docs nil)
  ;; (lsp-clients-typescript-preferences '(:includeCompletionsForImportStatements nil))
  ;; (lsp-solargraph-server-command '("solargraph" "socket"))
  ;; (lsp-log-io t)
  :init
  (defun +update-completions-list ()
    (progn
      (fset 'non-greedy-lsp (cape-capf-properties #'lsp-completion-at-point :exclusive 'no))
      (setq-local completion-at-point-functions
                  (list (cape-capf-super #'non-greedy-lsp #'yasnippet-capf)))))

  :hook
  (lsp-managed-mode . (lambda () (general-define-key
                                  :states '(normal)
                                  :keymaps 'local
                                  "K" 'lsp-describe-thing-at-point)))
  ;; (lsp-managed-mode . evil-normalize-keymaps)
  (lsp-completion-mode . +update-completions-list)
  ;; (lsp-managed-mode . eldoc-mode)
  :general
  (+leader-def
    :keymaps 'lsp-mode-map
    :infix "c"
    "a" '(lsp-execute-code-action :wk "Code action")
    "i" '(lsp-find-implementation :wk "Find implementation")
    "k" '(lsp-describe-thing-at-point :wk "Show hover doc")
    "l" '(lsp-avy-lens :wk "Click lens")
    "o" '(lsp-organize-imports :wk "Organize imports")
    "q" '(lsp-workspace-shutdown :wk "Shutdown workspace")
    "Q" '(lsp-workspace-restart :wk "Restart workspace")
    "r" '(lsp-rename :wk "Rename")
    ;; "R" '(lsp-find-references :wk "Restart workspace")
    )
  )

(use-package consult-lsp
  :general
  (+leader-def :keymaps 'lsp-mode-map
    "cj" '(consult-lsp-symbols :wk "Workspace symbols")
    "cx" '(consult-lsp-diagnostics :wk "Workspace diagnostics")))
#+end_src

* Project
#+begin_src emacs-lisp
(use-package project
  :ensure nil
  :demand t
  :commands (project-find-file
             project-switch-to-buffer
             project-switch-project
             project-switch-project-open-file)
  :config
  (setq project-switch-commands 'project-find-file)
  :general
  (+leader-def
    "p" '(:keymap project-prefix-map :wk "project")
    "p!" #'project-async-shell-command
    ))
#+end_src
* Tabspaces
#+begin_src emacs-lisp
(use-package tabspaces
  :custom
  (tabspaces-use-filtered-buffers-as-default t)
  (tabspaces-default-tab "home")
  (tabspaces-include-buffers '("*scratch*" "*Messages*"))
  (tabspaces-keymap-prefix nil)
  (tabspaces-initialize-project-with-todo nil)
  :general
  (+leader-def
    "<tab>" '(:keymap tabspaces-command-map :wk "workspaces")
    "<tab><tab>" #'tab-bar-switch-to-tab
    "<tab>n" #'tab-bar-switch-to-next-tab
    "<tab>p" #'tab-bar-switch-to-prev-tab)
  (+leader-def
    "pp" #'tabspaces-open-or-create-project-and-workspace)
  :init
  (tabspaces-mode 1)
  (tab-bar-rename-tab tabspaces-default-tab)

  (with-eval-after-load 'consult
    (consult-customize consult--source-buffer :hidden t :default nil)

    (defvar consult--source-workspace
      (list :name     "Workspace Buffers"
            :narrow   ?w
            :history  'buffer-name-history
            :category 'buffer
            :state    #'consult--buffer-state
            :default  t
            :items    (lambda () (consult--buffer-query
                                  :predicate (lambda (x) (and (tabspaces--local-buffer-p x) (not (popper-popup-p x))))
                                  :sort 'visibility
                                  :as #'buffer-name))))
    (add-to-list 'consult-buffer-sources 'consult--source-workspace))
  )
#+end_src

* Flycheck
#+begin_src emacs-lisp
(use-package flycheck
  :preface
  (defun +flycheck-eldoc (callback &rest _ignored)
    "Print flycheck messages at point by calling CALLBACK."
    (when-let ((flycheck-errors (and flycheck-mode (flycheck-overlay-errors-at (point)))))
      (mapc
       (lambda (err)
         (funcall callback
                  (format "%s: %s"
                          (let ((level (flycheck-error-level err)))
                            (pcase level
                              ('info (propertize "I" 'face 'flycheck-error-list-info))
                              ('error (propertize "E" 'face 'flycheck-error-list-error))
                              ('warning (propertize "W" 'face 'flycheck-error-list-warning))
                              (_ level)))
                          (flycheck-error-message err))
                  :thing (or (flycheck-error-id err)
                             (flycheck-error-group err))
                  :face 'font-lock-doc-face))
       flycheck-errors)))

  :custom
  (eldoc-documentation-strategy 'eldoc-documentation-compose-eagerly)
  (flycheck-checkers nil)
  (flycheck-display-errors-function nil)
  (flycheck-help-echo-function nil)
  (flycheck-buffer-switch-check-intermediate-buffers t)
  (flycheck-emacs-lisp-load-path 'inherit)
  (flycheck-check-syntax-automatically '(save idle-change mode-enabled))
  ;; :hook
  ;; (flycheck-mode . (lambda ()
  ;;                    (add-hook 'eldoc-documentation-functions #'+flycheck-eldoc 0 t)))
  )

#+end_src

* Projectile
#+begin_src emacs-lisp
  (defun projectile-run-eat (&optional arg)
    "Start Eat in the current projectile's root directory."
    (interactive "P")
    (let ((project (projectile-acquire-root)))
      (projectile-with-default-dir project
        (let ((eat-buffer-name (projectile-generate-process-name "eat" arg project)))
          (eat)))))

  (consult-project-function (lambda (_) (projectile-project-root)))
  (add-to-list 'marginalia-command-categories '(projectile-find-file . project-file))
  (add-to-list 'marginalia-command-categories '(projectile-recentf . project-file))

(use-package projectile
  :defer .3
  :commands (projectile-project-root
             projectile-project-name
             projectile-project-p
             projectile-locate-dominating-file
             projectile-relevant-known-projects)
  :custom
  ;; (projectile-enable-caching (not noninteractive))
  (projectile-project-search-path '("~/code"))
  (projectile-globally-ignored-files '(".DS_Store" "TAGS"))
  (projectile-globally-ignored-file-suffixes '(".elc" ".pyc" ".o"))
  (projectile-ignored-projects '("~/"))
  (projectile-kill-buffers-filter 'kill-only-files)
  :config
  ;; Reduce the number of project root marker files/directories for performance
  (setq projectile-project-root-files-bottom-up
        (append '(".projectile"
                  ".project"
                  ".git")))
  (setq projectile-project-root-files '())
  (setq projectile-project-root-files-top-down-recurring '("Makefile"))

  ;; Per-project compilation buffers
  (setq compilation-buffer-name-function #'projectile-compilation-buffer-name
        compilation-save-buffers-predicate #'projectile-current-project-buffer-p)

  (projectile-mode +1)
  :general
  (+leader-def :infix "p"
    "&" #'projectile-run-async-shell-command-in-root
    "!" #'projectile-run-async-shell-command-in-root
    "a" #'projectile-add-known-project
    "b" #'projectile-switch-to-buffer
    "c" #'projectile-compile-project
    "C" #'projectile-repeat-last-command
    "d" #'projectile-remove-known-project
    "D" #'projectile-dired
    "e" #'projectile-run-eshell
    "f" #'projectile-find-file
    "i" #'projectile-invalidate-cache
    "o" #'projectile-find-other-file
    "R" #'projectile-run-project
    "r" #'projectile-recentf
    "S" #'projectile-save-project-buffers
    "T" #'projectile-test-project)
  )

(use-package persp-projectile
  :after (projectile perspective)
  :general
  (+leader-def
    "pp" #'projectile-persp-switch-project))

#+end_src

* Perspective
#+begin_src emacs-lisp

(use-package perspective
  :demand t
  :custom
  (persp-sort 'created)
  (persp-show-modestring nil)
  (persp-initial-frame-name "home")
  (persp-mode-prefix-key (kbd "C-c M-p"))
  :general
  (+leader-def
    "<tab>" '(:keymap perspective-map :wk "workspaces")
    "<tab><tab>" #'persp-switch
    "<tab>k" '((lambda () (interactive) (persp-kill (persp-current-name))) :wk "Kill this workspace")
    )
  :preface
  (defun +persp-names ()
    "Return a list of the perspective names sorted in different direction."
    (let ((persps (hash-table-values (perspectives-hash))))
      (cond ((eq persp-sort 'name)
             (sort (mapcar 'persp-name persps) 'string<))
            ((eq persp-sort 'access)
             (mapcar 'persp-name
                     (sort persps (lambda (a b)
                                    (time-less-p (persp-last-switch-time a)
                                                 (persp-last-switch-time b))))))
            ((eq persp-sort 'created)
             (mapcar 'persp-name
                     (sort persps (lambda (a b)
                                    (time-less-p (persp-created-time a)
                                                 (persp-created-time b)))))))))
  :config
  (advice-add 'persp-names :override #'+persp-names)
  (persp-mode +1)

  (with-eval-after-load 'consult
    (consult-customize consult--source-buffer :hidden t :default nil)

    (defvar consult--source-workspace
      (list :name     "Workspace Buffers"
            :narrow   ?w
            :history  'buffer-name-history
            :category 'buffer
            :state    #'consult--buffer-state
            :default  t
            :items    (lambda () (consult--buffer-query
                                  :predicate (lambda (x) (and (persp-is-current-buffer x) (not (popper-popup-p x))))
                                  :sort 'visibility
                                  :as #'buffer-name))))
    (add-to-list 'consult-buffer-sources 'consult--source-workspace))
  )

(use-package perspective-tabs
  :after (perspective)
  :vc (:fetcher sourcehut :repo woozong/perspective-tabs)
  :config
  (perspective-tabs-mode +1))
#+end_src

* Eglot
#+begin_src emacs-lisp
;; (use-package eglot
;;   :ensure nil
;;   :commands eglot eglot-ensure
;;   :custom
;;   (eglot-sync-connect 1)
;;   (eglot-connect-timeout 10)
;;   (eglot-autoshutdown t)
;;   (eglot-ignored-server-capabilities '(:documentHighlightProvider))
;;   (eglot-extend-to-xref t)
;;   :init
;;   (setq eglot-stay-out-of '(eldoc))
;;   ;; (fset #'jsonrpc--log-event #'ignore)
;;   ;; (setf (plist-get eglot-events-buffer-config :size) 0)
;;   (setq eglot-workspace-configuration
;;         '(:solargraph (:diagnostics t)
;;           :gopls      (:staticcheck t)))

;;   ;; (setf (plist-get (plist-get eglot-workspace-configuration :gopls) :tags) "e2e")

;;   (defun +eglot-organize-imports ()
;;     (interactive)
;;        (eglot-code-actions nil nil "source.organizeImports" t))

;;   (defvar +eglot--help-buffer nil)
;;   (defun +eglot-describe-at-point ()
;;     (interactive)
;;     "Request documentation for the thing at point."
;;     (eglot--dbind ((Hover) contents range)
;;         (jsonrpc-request (eglot--current-server-or-lose) :textDocument/hover
;;                          (eglot--TextDocumentPositionParams))
;;       (let ((blurb (and (not (seq-empty-p contents))
;;                         (eglot--hover-info contents range)))
;;             (hint (thing-at-point 'symbol)))
;;         (if blurb
;;             (with-current-buffer
;;                 (or (and (buffer-live-p +eglot--help-buffer)
;;                          +eglot--help-buffer)
;;                     (setq +eglot--help-buffer (generate-new-buffer "*eglot-help*")))
;;               (with-help-window (current-buffer)
;;                 (rename-buffer (format "*eglot-help for %s*" hint))
;;                 (with-current-buffer standard-output (insert blurb))
;;                 (setq-local nobreak-char-display nil)))
;;           (display-local-help))))
;;     'deferred)

;;   (defun +eglot-capf ()
;;     (setq-local completion-at-point-functions
;;                 (list (cape-capf-super
;;                        #'eglot-completion-at-point
;;                        #'yasnippet-capf))))

;;   (defun +eglot-eldoc ()
;;     ;; Show flymake diagnostics first.
;;     (setq eldoc-documentation-functions
;;           (cons #'flymake-eldoc-function
;;                 (remove #'flymake-eldoc-function eldoc-documentation-functions)))
;;     ;; Show all eldoc feedback.
;;     (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly))
;;   :hook
;;   (eglot-managed-mode . (lambda () (general-define-key
;;                                     :states '(normal)
;;                                     :keymaps 'local
;;                                     "K" '+eglot-describe-at-point)))
;;   (eglot-managed-mode . +eglot-capf)
;;   (eglot-managed-mode . +eglot-eldoc)
;;   :general
;;   (+leader-def
;;     :keymaps 'eglot-mode-map
;;     :infix "c"
;;     "a" '(eglot-code-actions :wk "Code action")
;;     "i" '(eglot-find-implementation :wk "Find implementation")
;;     "k" '(+eglot-describe-at-point :wk "Show hover doc")
;;     "o" '(+eglot-organize-imports :wk "Organize imports")
;;     "q" '(eglot-shutdown :wk "Shutdown LSP")
;;     "Q" '(eglot-reconnect :wk "Restart LSP")
;;     "r" '(eglot-rename :wk "Rename"))
;;   )

;; (use-package eglot-booster
;;   :vc (:fetcher github :repo jdtsmith/eglot-booster)
;;   :after eglot
;;      :config
;;   (eglot-booster-mode))

;; (use-package consult-eglot
;;   :general
;;   (+leader-def
;;     :keymaps 'eglot-mode-map
;;     :infix "c"
;;     "j" '(consult-eglot-symbols :wk "Find symbol")))
#+end_src

* Rails
#+begin_src emacs-lisp

;; (defvar rails-command-prefix "bundle exec rails")

;; (defvar rails-generators
;;   '(("assets" (("app/assets/"
;;                 "app/assets/\\(?:stylesheets\\|javascripts\\)/\\(.+?\\)\\..+$")))
;;     ("controller" (("app/controllers/" "app/controllers/\\(.+\\)_controller\\.rb$")))
;;     ("generator" (("lib/generator/" "lib/generators/\\(.+\\)$")))
;;     ("helper" (("app/helpers/" "app/helpers/\\(.+\\)_helper.rb$")))
;;     ("integration_test" (("test/integration/" "test/integration/\\(.+\\)_test\\.rb$")))
;;     ("job" (("app/jobs/" "app/jobs/\\(.+\\)_job\\.rb$")))
;;     ("mailer" (("app/mailers/" "app/mailers/\\(.+\\)\\.rb$")))
;;     ("migration" (("db/migrate/" "db/migrate/[0-9]+_\\(.+\\)\\.rb$")))
;;     ("model" (("app/models/" "app/models/\\(.+\\)\\.rb$")))
;;     ("resource" (("app/models/" "app/models/\\(.+\\)\\.rb$")))
;;     ("scaffold" (("app/models/" "app/models/\\(.+\\)\\.rb$")))
;;     ("task" (("lib/tasks/" "lib/tasks/\\(.+\\)\\.rake$")))))

;; (defun rails-generate ()
;;   "Execute Rails generate COMMAND with input completion."
;;   (interactive)
;;   (let ((default-directory (project-root (project-current t))))
;;     (async-shell-command (rails-command-with-completion " generate "))))

;; (defun rails-destroy ()
;;   "Execute Rails destroy COMMAND with input completion."
;;   (interactive)
;;   (let ((default-directory (project-root (project-current t))))
;;     (async-shell-command (rails-command-with-completion " destroy "))))

;; (defun rails-command-with-completion (command)
;;   "Build Rails command from COMMAND with input completion."
;;   (let ((keymap (copy-keymap minibuffer-local-map))
;;         (command-prefix (concat rails-command-prefix command)))
;;     (define-key keymap (kbd "<tab>") 'rails--completion-in-region)
;;     (concat command-prefix (read-from-minibuffer command-prefix nil keymap))))

;; (defun rails--completion-in-region ()
;;   "Apply Rails generators for text completion in region."
;;   (interactive)
;;   (let ((generators (--map (concat (car it) " ") rails-generators)))
;;     (when (<= (minibuffer-prompt-end) (point))
;;       (completion-in-region (minibuffer-prompt-end) (point-max)
;;                             generators))))

;; (defun rails-server ()
;;   "Run rails server command."
;;   (interactive)
;;   (let ((default-directory (project-root (project-current t))))
;;     (async-shell-command (concat rails-command-prefix " server"))))

;; (defun rails-console ()
;;   "Start a rails console at project root."
;;   (interactive)
;;   (inf-ruby-console-rails (project-root (project-current t))))

;; (defun project-find-file-in-dir (dir)
;;   "Visit a file (with completion) in the current project.
;; The filename at point (determined by `thing-at-point'), if any,
;; is available as part of \"future history\"."
;;   (interactive)
;;   (let* ((pr (project-current t))
;;          (dirs (list (expand-file-name dir (project-root pr)))))
;;     (project-find-file-in (thing-at-point 'filename) dirs pr)))

;; (defun rails-find-controller ()
;;   (interactive)
;;   (project-find-file-in-dir "app/controllers/"))

;; ;; refactor to macro?
;; (defun rails-find-model ()
;;   (interactive)
;;   (project-find-file-in-dir "app/models/"))

;; (defun rails-find-view ()
;;   (interactive)
;;   (project-find-file-in-dir "app/views/"))

;; (defun rails-find-helper ()
;;   (interactive)
;;   (project-find-file-in-dir "app/helpers/"))

;; (defun rails-find-test ()
;;   (interactive)
;;   (project-find-file-in-dir "app/tests/"))

;; (defun rails-find-javascript ()
;;   (interactive)
;;   (project-find-file-in-dir "app/javascript/"))

;; (defun rails-find-job ()
;;   (interactive)
;;   (project-find-file-in-dir "app/jobs/"))

;; (defun rails-find-mailer ()
;;   (interactive)
;;   (project-find-file-in-dir "app/mailers/"))

;; ;; non macro
;; (defun rails-find-spec ()
;;   (interactive)
;;   (project-find-file-in-dir "app/spec/"))

;; (defun rails-find-migration ()
;;   (interactive)
;;   (project-find-file-in-dir "db/migrate/"))

;; (defun rails-find-stylesheet ()
;;   (interactive)
;;   (project-find-file-in-dir "app/assets/stylesheets/"))

;; (defun rails-find-initializer ()
;;   (interactive)
;;   (project-find-file-in-dir "config/initializers/"))

;; (defun rails-find-locale ()
;;   (interactive)
;;   (project-find-file-in-dir "config/locales/"))

;; (defvar rails-command-map
;;   (let ((map (make-sparse-keymap)))
;;     (define-key map (kbd "a") 'rails-find-locale)
;;     (define-key map (kbd "b") 'rails-find-job)
;;     (define-key map (kbd "c") 'rails-find-controller)
;;     (define-key map (kbd "d") 'rails-destroy)
;;     (define-key map (kbd "g") 'rails-generate)
;;     (define-key map (kbd "h") 'rails-find-helper)
;;     (define-key map (kbd "i") 'rails-find-initializer)
;;     (define-key map (kbd "j") 'rails-find-javascript)
;;     (define-key map (kbd "m") 'rails-find-model)
;;     (define-key map (kbd "n") 'rails-find-migration)
;;     (define-key map (kbd "p") 'rails-find-spec)
;;     (define-key map (kbd "r") 'rails-console)
;;     (define-key map (kbd "R") 'rails-server)
;;     (define-key map (kbd "s") 'rails-find-stylesheet)
;;     (define-key map (kbd "t") 'rails-find-test)
;;     (define-key map (kbd "u") 'rails-find-fixture)
;;     (define-key map (kbd "v") 'rails-find-view)
;;     (define-key map (kbd "w") 'rails-find-component)
;;     (define-key map (kbd "@") 'rails-find-mailer)
;;     map)
;;   "Keymap after `rails-keymap-prefix'.")
;; (fset 'rails-command-map rails-command-map)
#+end_src

* Java
#+begin_src emacs-lisp

;; (use-package lsp-java
;;   :preface
;;   (defun +java-mode-setup ()
;;     (setq tab-width 4)
;;     (add-hook 'before-save-hook 'lsp-format-buffer nil t)
;;     (setq-local lsp-enable-snippet nil)
;;     )
;;   :init
;;   (setq lsp-java-save-actions-organize-imports t)
;;   (setq lsp-java-completion-max-results 10)
;;   (setq lsp-java-vmargs '("-XX:+UseParallelGC" "-XX:GCTimeRatio=4" "-XX:AdaptiveSizePolicyWeight=90" "-Dsun.zip.disableMemoryMapping=true" "-Xmx2G" "-Xms100m"))
;;   :config
;;   (require 'lsp-java-boot)

;;   ;; workaround completions not showing up after .
;;   ;; (advice-add 'lsp-completion--looking-back-trigger-characterp :around
;;   ;;             (defun lsp-completion--looking-back-trigger-characterp@fix-dart-trigger-characters (orig-fn trigger-characters)
;;   ;;               (funcall orig-fn
;;   ;;                        (if (and (derived-mode-p 'java-ts-mode) (not trigger-characters))
;;   ;;                            ["."]
;;   ;;                          trigger-characters))))
;;   :hook
;;   (conf-javaprop-mode . lsp-deferred)
;;   ((java-mode java-ts-mode) . lsp-deferred)
;;   ((java-mode java-ts-mode) . +java-mode-setup))


#+end_src

* Agenda
#+begin_src emacs-lisp

(use-package org-agenda
  :ensure nil
  :init
  (setq org-agenda-sorting-strategy '((agenda habit-down time-up priority-down category-keep)
                                      (todo tag-up priority-down category-keep)
                                      (tags priority-down category-keep)
                                      (search category-keep)))
  (setq org-todo-keywords
        '((sequence "TODO(t)" "PROJ(p)" "|" "DONE(d!)")
          (sequence "[ ](T)" "|" "[X](x!)")))
  (setq org-refile-use-outline-path 'file)
  (setq org-refile-targets '(("tasks.org" :maxlevel . 1)))
  (setq org-agenda-files nil)
  (setq org-agenda-confirm-kill nil)
  (setq org-agenda-window-setup 'current-window)
  (setq org-agenda-restore-windows-after-quit t)
  (setq org-agenda-inhibit-startup t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-timestamp-if-done t)
  (setq org-capture-templates
        `(("t" "Task" entry (file "tasks.org")
           "* TODO %?\nSCHEDULED: %(org-insert-time-stamp (org-read-date nil t))")
          ("e" "Emacs todo" entry (file+olp "~/.config/emacs/init.org" "Todos")
           "* %?")
          ("v" "Vocalubary" entry (file "vocab.org")
           "* %?")
          ))

  :hook
  (org-agenda-mode . hl-line-mode)
  (org-agenda-mode . (lambda ()
                       (interactive) (org-element-cache-reset 'all)))
  (org-capture-mode . evil-insert-state)
  (org-capture-mode . (lambda ()
                        (setq header-line-format
                              (format "%s%s%s"
                                      (propertize (abbreviate-file-name (buffer-file-name (buffer-base-buffer)))
                                                  'face 'font-lock-string-face)
                                      " → "
                                      header-line-format))))
  :config
  ;; Refresh agenda after capturing.
  (add-hook 'org-capture-after-finalize-hook 'org-agenda-maybe-redo)

  ;; Save agenda buffers after doing these actions
  (dolist (hook '(org-refile
                  org-agenda-archive
                  org-agenda-add-note
                  org-agenda-deadline
                  org-agenda-kill
                  org-agenda-todo
                  org-agenda-refile
                  org-agenda-schedule
                  org-agenda-set-property
                  org-agenda-set-tags))
    ;; https://github.com/bbatsov/helm-projectile/issues/51
    (advice-add hook :after (lambda (&rest _) (org-save-all-org-buffers))))

  ;; need this because syncing updates from cloud show categories as ???
  (advice-add #'org-agenda-redo :after (lambda (&rest _) (org-element-cache-reset t)))

  (with-eval-after-load 'evil
    (evil-define-key 'emacs org-agenda-mode-map
      "j" 'org-agenda-next-line
      "k" 'org-agenda-previous-line
      "x" 'org-agenda-bulk-action
      "q" 'org-agenda-exit

      "M-j" 'org-agenda-drag-line-forward
      "M-k" 'org-agenda-drag-line-backward

      "dd" 'org-agenda-kill
      "dA" 'org-agenda-archive
      )
    )
  )

;; (use-package org-super-agenda
;;   :after (org-agenda)
;;   :config
;;   (setq org-agenda-span 'day)
;;   (setq org-agenda-time-grid '((daily) () "" ""))
;;   (setq org-agenda-prefix-format
;;         '(
;;           (agenda . " %i %-12:c%?-12t ")
;;           (todo . " %i %-12:c")
;;           (tags . " %i %-12:c")
;;           (search . " %i %-12:c")
;;           ))
;;   (setq org-super-agenda-groups
;;         '(
;;           (:name "Habits" :and(:category "habits" :todo "TODO")) ;; warning
;;           (:name "Today" :time-grid t)
;;           (:name "Emacs" :tag "emacs")
;;           (:name "Shopping" :tag "shopping")
;;           (:name "Others" :todo "TODO")
;;           ))
;;   (setq org-super-agenda-header-map (make-sparse-keymap))
;;   (org-super-agenda-mode 1)
;;   )
#+end_src
